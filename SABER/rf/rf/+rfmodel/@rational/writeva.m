function status = writeva(h, filename, innets, outnets, discipline,     ...
    printformat, filestoinclude)
%WRITEVA Write Verilog-A description of a rational function object.
%   STATUS = WRITEVA(H, FILENAME, INNETS, OUTNETS, DISCIPLINE, PRINTFORMAT,
%   FILESTOINCLUDE) writes a Verilog-A module that describes a rational
%   function object, H, to the file specified by filename. The function
%   implements the object as Laplace Transform S-domain filters in
%   Verilog-A. It returns a status of True if the operation is successful
%   and False otherwise.
% 
%   H is the handle to the RFMODEL.RATIONAL object. FILENAME is a string
%   representing the name of the Verilog-A file to which to write the
%   module. INNETS is a string or a cell of two strings that specifies the
%   name of each of the module?s input nets. OUTNETS is a string or a cell
%   of two strings that specifies the name of each of the module?s output
%   nets. DISCIPLINE is a string that specifies the predefined Verilog-A
%   discipline of the nets. PRINTFORMAT is a string that specifies the
%   precision of the numerator and denominator coefficients of the
%   Verilog-A filter using the C language conversion specifications.
%   FILESTOINCLUDE is a cell of strings that specifies a list of header
%   files to include in the module using Verilog-A '`include' statements.
%
%   See also RFMODEL.RATIONAL, RFMODEL.RATIONAL/ISPASSIVE, 
%   RFMODEL.RATIONAL/TIMERESP, RFMODEL.RATIONAL/STEPRESP,
%   RFMODEL.RATIONAL/FREQRESP, RATIONALFIT

%   Copyright 2006-2009 The MathWorks, Inc.

narginchk(1, 7)
status = false; % initialize status

% error checking on filename
if nargin < 2
    [filename, net_filename, no_err] = check_filename;
else
    [filename, net_filename, no_err] = check_filename(filename);
end
if ~no_err
    return
end
% end of error checking for filename

% error checking on ports
if nargin < 3
    innets = {'in'};
else
    innets = check_ports(innets, 'INNETS');
end
if nargin < 4
    outnets = {'out'};
else
    outnets = check_ports(outnets, 'OUTNETS');
end
% end of error checking on ports

% error checking on discipline
if nargin < 5
    discipline = 'electrical';
else
    check_discipline(discipline);
end
% end of error checking on discipline

% error checking on printformat
if nargin < 6
    printformat = '%15.10e';
else
    check_printformat(printformat);
end
% end of error checking on printformat

% error checking on filestoinclude
if nargin < 7
    filestoinclude = {'disciplines.vams'};
else
    filestoinclude = check_filestoinclude(filestoinclude,'FILESTOINCLUDE');
end
% end of error checking on filestoinclude

% check if rational function contains valid data
checkproperty(h);
check_range(h.Delay, true, 'The delay of the rational model');
check_range(h.D, true, ...
    'The direct feed through coefficient of the rational model');
% get sets of real numerators and denominators (cell of vectors)
[my_a, my_c] = reorder(h);
[num, den] = convert2real(my_a, my_c);

% open an empty text file
fid = fopen(filename, 'wt');
% Throw an error when fid is -1
if fid == -1
    error(message('rf:rfmodel:rational:writeva:FailOpenFile', filename))
end

% make a comment that the module is generated by the MathWorks tool
fprintf(fid, '// Module: %s\n\n',net_filename);
ver_matlab = ver('matlab');
ver_rf = ver('rf');
fprintf(fid, '// Generated by MATLAB(R) %s and the RF Toolbox %s.\n\n', ...
    ver_matlab(1).Version, ver_rf(1).Version);
fprintf(fid, '// Generated on: %s\n\n', datestr(clock));

% include header files
write_filestoinclude(fid, filestoinclude)

% construct input ports and output ports print format
in_format = get_netsformat(innets);
out_format = get_netsformat(outnets);
[allnets_format, allnets] = get_allnetsformat(innets, outnets);

% write module name
fprintf(fid, ['module %s(', allnets_format, ');\n'],                    ...
    net_filename, allnets{:});

% declare input and output ports
declare_ports(fid, allnets_format, allnets, discipline,                 ...
    h.Delay);

% declare numerator and denominator variables
declare_var(fid, num, den);

% start writing analog block
fprintf(fid, ' analog begin\n\n');

% assign value to variables at initial step
assign_var(fid, num, den, printformat);

% write laplace transform
write_laplace(fid, innets, in_format, outnets, out_format,              ...
    printformat, h.Delay, h.D, numel(num));

fprintf(fid, ' end\n'); % end of analog block
fprintf(fid, 'endmodule'); % end of module

% close the file
fclose(fid);
status = true;

end % of writeva

%---------------------
function ports = check_ports(ports, name)
% Error checking for ports

if iscell(ports)
    if numel(ports) ~= 1 && numel(ports) ~= 2
        error(message('rf:rfmodel:rational:writeva:WrongNumberOfNets',  ...
            name))
    end
    nports = numel(ports);
    for k = 1:nports
        if ~ischar(ports{k}) || size(ports{k}, 1) ~= 1
            error(message('rf:rfmodel:rational:writeva:NetsNotChar',    ...
                name))
        end
    end
elseif ischar(ports)
    if size(ports, 1) ~= 1
        error(message(['rf:rfmodel:rational:writeva:'                   ...
            'TwoDimCharArrayNotAllowed2Str'], name))
    end
    temp = {ports};
    ports = temp; % convert to cell of one string for printing purpose
else
    error(message('rf:rfmodel:rational:writeva:PortsNotCharOrCell', name))
end

end % of check_ports

%---------------------
function files = check_filestoinclude(files, name)
% Error checking for filestoinclude

if iscell(files)
    nfiles = numel(files);
    for k = 1:nfiles
        if ~ischar(files{k}) || size(files{k}, 1) ~= 1
            error(message(['rf:rfmodel:rational:writeva:'               ...
                'FilesToIncludeNotChar'], name))
        end
    end
elseif ischar(files)
    if size(files, 1) ~= 1
        error(message(['rf:rfmodel:rational:writeva:'                   ...
            'TwoDimCharArrayNotAllowedNStr'], name))
    end
    temp = {files};
    files = temp; % convert to cell of one string
else
    error(message(['rf:rfmodel:rational:writeva:'                       ...
        'FilesToIncludeNotCharOrCell'], name))
end

end % of check_filestoinclude

%------------------------------
function [my_a, my_c] = reorder(h)
% Rearrange the order of poles and residues so that only one of the complex
% conjugate poles and residues pair appear.

A = h.A;
C = h.C;
temp_a = zeros(length(A), 1);
temp_c = zeros(length(C), 1);

kk = 1;
nA = length(A);
for ii = 1:nA
    if isnan(A(ii))
        continue
    elseif isreal(A(ii)) % real pole and residue
        if ~isreal(C(ii))
            error(message('rf:rfmodel:rational:writeva:RealAComplexC'));
        end
    else % complex poles and residues
        % try to find the conjugate of this complex pole
        pos = find(A == conj(A(ii)), 1);
        if isempty(pos)
            error(message('rf:rfmodel:rational:writeva:MissConjugateA', ...
                num2str( A( ii ) )));
        end
        % check if the corresponding residues are complex conjugate
        if C(ii) ~= conj(C(pos))
            error(message('rf:rfmodel:rational:writeva:AandCMismatch',  ...
                num2str( C( ii ) ), num2str( C( pos ) ),                ...
                num2str( A( ii ) ), num2str( A( pos ) )));
        end
        A(pos) = NaN; % set complex conjugate to NaN
        C(pos) = NaN;
    end
    temp_a(kk) = A(ii);
    temp_c(kk) = C(ii);
    kk = kk + 1;
end

my_a = temp_a(1:kk-1);
my_c = temp_c(1:kk-1);

end % reorder

%------------------------------
function [num, den] = convert2real(my_a, my_c)
% Convert real and complex poles and residues into real numerators and
% denominators of Laplace Transform S-domain filters.

den = cell(length(my_a), 1);
num = cell(length(my_a), 1);
n_my_a = length(my_a);
for ii = 1:n_my_a
    if isreal(my_a(ii))
        % real pole
        num{ii} = check_range(my_c(ii), false);
        den{ii} = [1, check_range(-my_a(ii))];
    else
        % complex poles
        a = real(my_a(ii));
        b = imag(my_a(ii));
        c = real(my_c(ii));
        d = imag(my_c(ii));
        num{ii} = [check_range(2*c, false), check_range(-2*(a*c+b*d))];
        den{ii} = [1, check_range(-2*a), check_range(a^2+b^2)];
    end
end

end % of convert2real

%------------------------------
function [filename, net_filename, no_err] = check_filename(filename)
% Error checking for filename. FILENAME may contain path. NET_FILENAME
% contains only filename with no extension.

no_err = true;
net_filename = '';

OVERWRITE_CHECK = true;
% display a dialog box used to select a file for saving
if nargin < 1 || isempty(strtok(filename))
    [filename, pathname] = uiputfile('*.va', 'Save as');
    if isequal(filename,0) || isequal(pathname,0)
        no_err = false;
        filename = '';
        return;
    end
    filename = fullfile(pathname, filename);
    OVERWRITE_CHECK = false;
end

if ~ischar(filename)
    error(message('rf:rfmodel:rational:writeva:InvalidFilename'))
end

filename = strtrim(filename);
[pathname, net_filename, ext] = fileparts(filename);
% check whether the net_filename contains any extension
if isempty(ext) % no extension
    filename = [filename, '.va'];
elseif strcmpi(ext, '.va') % extension is .va
    % filename = fullfile(pathname, [net_filename, '.va']);
else % extension is not .va
    error(message('rf:rfmodel:rational:writeva:ExtensionNotVA'));
end

% overwrite check
if OVERWRITE_CHECK
    if exist(filename, 'file')
        button = questdlg([filename, ' already exists. ', ...
            'Do you want to replace it?'], ...
            'Continue Operation','Yes','No','Yes');
        if isempty(button) || strcmp(button,'No')
            % prompt users to select a different file
            [filename, net_filename, no_err] = check_filename;
        end
    end
end

end % of check_filename

%------------------------------
function check_discipline(discipline)
% Error checking for discipline

if ~ischar(discipline) || size(discipline, 1) ~= 1
    error(message('rf:rfmodel:rational:writeva:DisciplineNotChar'));
end

end % of check_discipline

%------------------------------
function check_printformat(printformat)
% Error checking for printformat

if ~ischar(printformat) || ~((isequal(regexpi(strtrim(printformat), ...
        '%[+-]?[0-9]*[.]?[0-9]*[eg]'), 1) || ...
        isequal(regexp(strtrim(printformat), ...
        '%[+-]?[0-9]*[.]?[0-9]*[fdiu]'), 1)))
    error(message('rf:rfmodel:rational:writeva:PrintformatNotChar'));
end

end % of check_printformat

%------------------------------
function write_filestoinclude(fid, filestoinclude)
% Write included header files
nfilestoinclude = numel(filestoinclude);
for k = 1:nfilestoinclude
    fprintf(fid, '`include "%s"\n', filestoinclude{k});
end
fprintf(fid, '\n');

end % of write_filestoinclude

%-------------------------------
function [format, allnets] = get_allnetsformat(innets, outnets)
% Get print format for all input and output nets

% find out if same net is used in both input and output
idx_innets = logical([0 0]);
ninnets = numel(innets);
for ii = 1:ninnets
    if any(strcmp(innets{ii}, outnets))
        idx_innets(ii) = 1;
    end
end
innets(idx_innets) = [];
allnets = {innets{:}, outnets{:}};
format = [repmat('%s, ', [1, numel(allnets)-1]), '%s'];

end % of get_allnetsformat

%-------------------------------
function format = get_netsformat(nets)
% Get print format for input/output to Laplace Transform

if numel(nets) == 2
    format = '%s, %s';
else
    format = '%s';
end

end % of get_netsformat

%--------------------------------
function declare_ports(fid, allnets_format, allnets, discipline, delay)

% declare the discipline of ports
fprintf(fid, [' %s ', allnets_format, ';\n'], discipline, allnets{:});
% declare an internal net if delay is not zero
if delay ~= 0
    fprintf(fid, ' %s node1;\n', discipline);
end
fprintf(fid, '\n');

end % of declare_ports

%--------------------------------
function declare_var(fid, num, den)

% declare numerator variables
fprintf(fid, ' real ');
nnum = numel(num);
for idx = 1:nnum
    fprintf(fid, 'nn%d[0:%d]', idx,  length(num{idx})-1);
    if idx ~= nnum
        fprintf(fid, ', ');
    end
end
fprintf(fid, ';\n real ');
% declare denominator variables
nden = numel(den);
for idx = 1:nden
    fprintf(fid, 'dd%d[0:%d]', idx,  length(den{idx})-1);
    if idx ~= nden
        fprintf(fid, ', ');
    end
end
fprintf(fid, ';\n\n');

end % of declare_var

%---------------------------------
function assign_var(fid, num, den, printformat)
%Assign values to variables at initial step

fprintf(fid, [blanks(3), '@(initial_step) begin\n']);
nnum = numel(num);
for idx = 1:nnum
    Lnum = length(num{idx});
    for k = 0:Lnum-1
        fprintf(fid, [blanks(5), 'nn%d[%d] = ', printformat, ';\n'],...
            idx, k, num{idx}(Lnum-k));
    end

    Lden = length(den{idx});
    for n = 0:Lden-1
        fprintf(fid, [blanks(5), 'dd%d[%d] = ', printformat, ';\n'],...
            idx, n, den{idx}(Lden-n));
    end
end
fprintf(fid, [blanks(3), 'end\n\n']);

end % of assign_var

%------------------------------------
function write_laplace(fid, innets, in_format, outnets, out_format,     ...
    printformat, delay, dft, lnum)

if delay == 0 % no delay
    % write direct feed through
    if dft ~= 0
        fprintf(fid,[blanks(3), 'V(', out_format, ') <+ ', printformat, ...
            '*V(', in_format, ');\n'], outnets{:}, dft, innets{:});
    end
    % write Laplace transform
    for idx = 1:lnum
        fprintf(fid,[blanks(3), 'V(', out_format, ') <+ laplace_nd(V(', ...
            in_format, '), nn%d, dd%d);\n'], outnets{:}, innets{:}, ...
            idx, idx);
    end
else
    % write direct feed through
    if dft ~= 0
        fprintf(fid, [blanks(3), 'V(node1) <+ ', printformat,           ...
            '*V(', in_format, ');\n'], dft, innets{:});
    end
    % write Laplace transform
    for idx = 1:lnum
        fprintf(fid, [blanks(3), 'V(node1) <+ laplace_nd(V(',           ...
            in_format, '), nn%d, dd%d);\n'], innets{:}, ...
            idx, idx);
    end
    % write delay
    fprintf(fid,[blanks(3), 'V(', out_format,                           ...
        ') <+ absdelay(V(node1), ', printformat, ');\n'],               ...
        outnets{:}, delay);
end

end % of write_laplace

%-------------------------------------
function y = in_range(x)
% Check if x is in the Verilog-A real number range.

y = (abs(x) <= 1e37) && (abs(x) >= 1e-37);

end % of in_range

%-------------------------------------
function x = check_range(x, zero_included, desc)
% Check if numeric values are out of Verilog-A real number range.

if nargin < 2
    zero_included = true;
end
if zero_included && x == 0
    return
end

if nargin < 3
    desc = 'The Laplace transform coefficient';
end
    
if ~all(in_range(x))
    error(message('rf:rfmodel:rational:writeva:CoeffOutOfRange', desc));
end

end % of check_range

% [Eof writeva.m]